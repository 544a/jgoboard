<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jgocanvas.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jgocanvas.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Import or create JGO namespace
var JGO = JGO || {};

(function() {
    'use strict';

    /**
     * Create a jGoBoard canvas object.
     *
     * @param {Object} elem Container HTML element or its id.
     * @param {Object} opt Options object.
     * @param {JGO.Stones} stones Stone and marker drawing facility.
     * @param {Image} boardTexture Board texture or false if none.
     * @constructor
     * @memberof JGO
     */
    JGO.Canvas = function(elem, opt, stones, boardTexture) {
        if(typeof elem === 'string')
            elem = document.getElementById(elem);

        var canvas = document.createElement('canvas'),
            self = this, i, j;

        var padLeft = opt.edge.left ? opt.padding.normal : opt.padding.clipped,
            padRight = opt.edge.right ? opt.padding.normal : opt.padding.clipped,
            padTop = opt.edge.top ? opt.padding.normal : opt.padding.clipped,
            padBottom = opt.edge.bottom ? opt.padding.normal : opt.padding.clipped;

        this.marginLeft = opt.edge.left ? opt.margin.normal : opt.margin.clipped;
        this.marginRight = opt.edge.right ? opt.margin.normal : opt.margin.clipped;
        this.marginTop = opt.edge.top ? opt.margin.normal : opt.margin.clipped;
        this.marginBottom = opt.edge.bottom ? opt.margin.normal : opt.margin.clipped;

        this.boardWidth = padLeft + padRight +
            opt.grid.x * opt.view.width;
        this.boardHeight = padTop + padBottom +
            opt.grid.y * opt.view.height;

        this.width = canvas.width =
        this.marginLeft + this.marginRight + this.boardWidth;
        this.height = canvas.height =
        this.marginTop + this.marginBottom + this.boardHeight;

        this.listeners = {'click': [], 'mousemove': [], 'mouseout': []};

        /**
         * Get board coordinate based on screen coordinates.
         * @param {number} x Coordinate.
         * @param {number} y Coordinate.
         * @returns {JGO.Coordinate} Board coordinate.
         */
        this.getCoordinate = function(pageX, pageY) {
            var bounds = canvas.getBoundingClientRect(),
                scaledX = (pageX - bounds.left) * canvas.width / (bounds.right - bounds.left),
                scaledY = (pageY - bounds.top) * canvas.height / (bounds.bottom - bounds.top);

            return new JGO.Coordinate(
                Math.floor((scaledX-self.marginLeft-padLeft)/opt.grid.x) + opt.view.xOffset,
                Math.floor((scaledY-self.marginTop-padTop)/opt.grid.y) + opt.view.yOffset);
        };

        // Click handler will call all listeners passing the coordinate of click
        // and the click event
        canvas.onclick = function(ev) {
            var c = self.getCoordinate(ev.clientX, ev.clientY),
                listeners = self.listeners.click;

            for(var l=0; l&lt;listeners.length; l++)
                listeners[l].call(self, c.copy(), ev);
        };

        var lastMove = new JGO.Coordinate(-1,-1);

        // Move handler will call all listeners passing the coordinate of move
        // whenever mouse moves over a new intersection
        canvas.onmousemove = function(ev) {
            if(!self.listeners.mousemove.length) return;

            var c = self.getCoordinate(ev.clientX, ev.clientY),
                listeners = self.listeners.mousemove;

            if(c.i &lt; self.opt.view.xOffset ||
                c.i >= self.opt.view.xOffset + self.opt.view.width)
                c.i = -1;

            if(c.j &lt; self.opt.view.yOffset ||
                c.j >= self.opt.view.yOffset + self.opt.view.height)
                c.j = -1;

            if(lastMove.equals(c))
                return; // no change
            else
                lastMove = c.copy();

            for(var l=0; l&lt;listeners.length; l++)
                listeners[l].call(self, c.copy(), ev);
        };

        // Mouseout handler will again call all listeners of that event, no
        // coordinates will be passed of course, only the event
        canvas.onmouseout = function(ev) {
            var listeners = self.listeners.mouseout;

            for(var l=0; l&lt;listeners.length; l++)
                listeners[l].call(self, ev);
        };

        elem.appendChild(canvas);

        this.ctx = canvas.getContext('2d');
        this.opt = opt;
        this.stones = stones;
        this.boardTexture = boardTexture;

        // Fill margin with correct color
        this.ctx.fillStyle = opt.margin.color;
        this.ctx.fillRect(0, 0, canvas.width, canvas.height);

        if(this.boardTexture) {
            // Prepare to draw board with shadow
            this.ctx.save();
            this.ctx.shadowColor = opt.boardShadow.color;
            this.ctx.shadowBlur = opt.boardShadow.blur;
            this.ctx.shadowOffsetX = opt.boardShadow.offX;
            this.ctx.shadowOffsetX = opt.boardShadow.offY;

            var clipTop = opt.edge.top ? 0 : this.marginTop,
                clipLeft = opt.edge.left ? 0 : this.marginLeft,
                clipBottom = opt.edge.bottom ? 0 : this.marginBottom,
                clipRight = opt.edge.right ? 0 : this.marginRight;

            // Set clipping to throw shadow only on actual edges
            this.ctx.beginPath();
            this.ctx.rect(clipLeft, clipTop,
                canvas.width - clipLeft - clipRight,
            canvas.height - clipTop - clipBottom);
            this.ctx.clip();

            this.ctx.drawImage(this.boardTexture, 0, 0,
                this.boardWidth, this.boardHeight,
                this.marginLeft, this.marginTop,
            this.boardWidth, this.boardHeight);

            // Draw lighter border around the board to make it more photography
            this.ctx.strokeStyle = opt.border.color;
            this.ctx.lineWidth = opt.border.lineWidth;
            this.ctx.beginPath();
            this.ctx.rect(this.marginLeft, this.marginTop,
            this.boardWidth, this.boardHeight);
            this.ctx.stroke();

            this.ctx.restore(); // forget shadow and clipping
        }

        // Top left center of grid (not edge, center!)
        this.gridTop = this.marginTop + padTop + opt.grid.y / 2;
        this.gridLeft = this.marginLeft + padLeft + opt.grid.x / 2;

        this.ctx.strokeStyle = opt.grid.color;

        var smt = this.opt.grid.smooth; // with 0.5 there will be full antialias

        // Draw vertical gridlines
        for(i=0; i&lt;opt.view.width; i++) {
            if((i === 0 &amp;&amp; opt.edge.left) || (i+1 == opt.view.width &amp;&amp; opt.edge.right))
                this.ctx.lineWidth = opt.grid.borderWidth;
            else
                this.ctx.lineWidth = opt.grid.lineWidth;

            this.ctx.beginPath();

            this.ctx.moveTo(smt + this.gridLeft + opt.grid.x * i,
                smt + this.gridTop - (opt.edge.top ? 0 : opt.grid.y / 2 + padTop/2));
            this.ctx.lineTo(smt + this.gridLeft + opt.grid.x * i,
                smt + this.gridTop + opt.grid.y * (opt.view.height - 1) +
                (opt.edge.bottom ? 0 : opt.grid.y / 2 + padBottom/2));
            this.ctx.stroke();
        }

        // Draw horizontal gridlines
        for(i=0; i&lt;opt.view.height; i++) {
            if((i === 0 &amp;&amp; opt.edge.top) || (i+1 == opt.view.height &amp;&amp; opt.edge.bottom))
                this.ctx.lineWidth = opt.grid.borderWidth;
            else
                this.ctx.lineWidth = opt.grid.lineWidth;

            this.ctx.beginPath();

            this.ctx.moveTo(smt + this.gridLeft - (opt.edge.left ? 0 : opt.grid.x / 2 + padLeft/2),
            smt + this.gridTop + opt.grid.y * i);
            this.ctx.lineTo(smt + this.gridLeft + opt.grid.x * (opt.view.width - 1) +
                (opt.edge.right ? 0 : opt.grid.x / 2 + padRight/2),
            smt + this.gridTop + opt.grid.y * i);
            this.ctx.stroke();
        }

        if(opt.stars.points) { // If star points
            var step = (opt.board.width - 1) / 2 - opt.stars.offset;
            // 1, 4, 5, 8 and 9 points are supported, rest will result in randomness
            for(j=0; j&lt;3; j++) {
                for(i=0; i&lt;3; i++) {
                    if(j == 1 &amp;&amp; i == 1) { // center
                        if(opt.stars.points % 2 === 0)
                            continue; // skip center
                    } else if(i == 1 || j == 1) { // non-corners
                        if(opt.stars.points &lt; 8)
                            continue; // skip non-corners
                    } else { // corners
                        if(opt.stars.points &lt; 4)
                            continue; // skip corners
                    }

                    var x = (opt.stars.offset + i * step) - opt.view.xOffset,
                    y = (opt.stars.offset + j * step) - opt.view.yOffset;

                    if(x &lt; 0 || y &lt; 0 || x >= opt.view.width || y >= opt.view.height)
                        continue; // invisible

                    this.ctx.beginPath();
                    this.ctx.arc(smt + this.gridLeft + x * opt.grid.x,
                        smt + this.gridTop + y * opt.grid.y,
                    opt.stars.radius, 2*Math.PI, false);
                    this.ctx.fillStyle = opt.grid.color;
                    this.ctx.fill();
                }
            }
        }

        this.ctx.font = opt.coordinates.font;
        this.ctx.fillStyle = opt.coordinates.color;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';

        // Draw horizontal coordinates
        for(i=0; i&lt;opt.view.width; i++) {
            if(opt.coordinates &amp;&amp; opt.coordinates.top)
                this.ctx.fillText(JGO.COORDINATES[i + opt.view.xOffset],
                    this.gridLeft + opt.grid.x * i,
                    this.marginTop / 2);
            if(opt.coordinates &amp;&amp; opt.coordinates.bottom)
                this.ctx.fillText(JGO.COORDINATES[i + opt.view.xOffset],
                    this.gridLeft + opt.grid.x * i,
                    canvas.height - this.marginBottom / 2);
        }

        // Draw vertical coordinates
        for(i=0; i&lt;opt.view.height; i++) {
            if(opt.coordinates &amp;&amp; opt.coordinates.left)
                this.ctx.fillText(''+(opt.board.height-opt.view.yOffset-i),
            this.marginLeft / 2,
                this.gridTop + opt.grid.y * i);
            if(opt.coordinates &amp;&amp; opt.coordinates.right)
                this.ctx.fillText(''+(opt.board.height-opt.view.yOffset-i),
                canvas.width - this.marginRight / 2,
                    this.gridTop + opt.grid.y * i);
        }

        // Store rendered board in another canvas for fast redraw
        this.backup = document.createElement('canvas');
        this.backup.width = canvas.width;
        this.backup.height = canvas.height;
        this.backup.getContext('2d').drawImage(canvas,
            0, 0, canvas.width, canvas.height,
            0, 0, canvas.width, canvas.height);

        this.restore = function(x, y, w, h) {
            x = Math.floor(x);
            y = Math.floor(y);
            this.ctx.drawImage(this.backup, x, y, w, h, x, y, w, h);
        };

        // Clip further drawing to board only
        this.ctx.beginPath();
        this.ctx.rect(this.marginLeft, this.marginTop, this.boardWidth, this.boardHeight);
        this.ctx.clip();
    };

    /**
     * Get X coordinate based on column.
     * @returns {number} Coordinate.
     */
    JGO.Canvas.prototype.getX = function(i) {
        return this.gridLeft + this.opt.grid.x * i;
    };

    /**
     * Get Y coordinate based on row.
     * @returns {number} Coordinate.
     */
    JGO.Canvas.prototype.getY = function(j) {
        return this.gridTop + this.opt.grid.y * j;
    };

    /**
     * Redraw canvas portion using a board.
     *
     * @param {JGO.Board} jboard Board object.
     * @param {number} i1 Starting column to be redrawn.
     * @param {number} j1 Starting row to be redrawn.
     * @param {number} i2 Ending column to be redrawn (inclusive).
     * @param {number} j2 Ending row to be redrawn (inclusive).
     */
    JGO.Canvas.prototype.draw = function(jboard, i1, j1, i2, j2) {
        var self = this;
        i1 = Math.max(i1, this.opt.view.xOffset);
        j1 = Math.max(j1, this.opt.view.yOffset);
        i2 = Math.min(i2, this.opt.view.xOffset + this.opt.view.width - 1);
        j2 = Math.min(j2, this.opt.view.yOffset + this.opt.view.height - 1);

        if(i2 &lt; i1 || j2 &lt; j1)
            return; // nothing to do here

        var x = this.getX(i1 - this.opt.view.xOffset) - this.opt.grid.x,
            y = this.getY(j1 - this.opt.view.yOffset) - this.opt.grid.y,
            w = this.opt.grid.x * (i2 - i1 + 2),
            h = this.opt.grid.y * (j2 - j1 + 2);

        this.ctx.save();

        this.ctx.beginPath();
        this.ctx.rect(x, y, w, h);
        this.ctx.clip(); // only apply redraw to relevant area
        //alert('Restore' + x + ', ' + y + ' and ' + w + ' x ' + h);
        this.restore(x, y, w, h); // restore background

        // Expand redrawn intersections while keeping within viewport
        i1 = Math.max(i1-1, this.opt.view.xOffset);
        j1 = Math.max(j1-1, this.opt.view.yOffset);
        i2 = Math.min(i2+1, this.opt.view.xOffset + this.opt.view.width - 1);
        j2 = Math.min(j2+1, this.opt.view.yOffset + this.opt.view.height - 1);

        var isLabel = /^[a-zA-Z1-9]/;

        // Stone radius derived marker size parameters
        var stoneR = this.opt.stone.radius,
            clearW = stoneR * 1.5, clearH = stoneR * 1.2, clearFunc;

        // Clear grid for labels on clear intersections before casting shadows
        if(this.boardTexture) { // there is a board texture
            clearFunc = function(ox, oy) {
                self.ctx.drawImage(self.boardTexture,
                    ox - self.marginLeft - clearW / 2, oy - self.marginTop - clearH / 2, clearW, clearH,
                    ox - clearW / 2, oy - clearH / 2, clearW, clearH);
            };
        } else { // no board texture
            this.ctx.fillStyle = this.opt.margin.color;
            clearFunc = function(ox, oy) {
                self.ctx.fillRect(ox - clearW / 2, oy - clearH / 2, clearW, clearH);
            };
        }

        jboard.each(function(c, type, mark) {
            // Note: Use of smt has been disabled here for clear results
            var ox = self.getX(c.i - self.opt.view.xOffset),
                oy = self.getY(c.j - self.opt.view.yOffset);

            if(type == JGO.CLEAR &amp;&amp; mark &amp;&amp; isLabel.test(mark))
                clearFunc(ox, oy);
        }, i1, j1, i2, j2); // provide iteration limits

        // Shadows
        if(this.stones.drawShadow !== false) {
            jboard.each(function(c, type) {
                var ox = self.getX(c.i - self.opt.view.xOffset),
                    oy = self.getY(c.j - self.opt.view.yOffset);

                if(type == JGO.BLACK || type == JGO.WHITE) {
                    self.stones.drawShadow(self.ctx,
                                           self.opt.shadow.xOff + ox,
                                           self.opt.shadow.yOff + oy);
                }
            }, i1, j1, i2, j2); // provide iteration limits
        }

        // Stones and marks
        jboard.each(function(c, type, mark) {
            var ox = (self.getX(c.i - self.opt.view.xOffset)),
                oy = (self.getY(c.j - self.opt.view.yOffset));
            var markColor;

            switch(type) {
            case JGO.BLACK:
            case JGO.DIM_BLACK:
                self.ctx.globalAlpha = type == JGO.BLACK ? 1 : self.opt.stone.dimAlpha;
                self.stones.drawStone(self.ctx, JGO.BLACK, ox, oy);
                markColor = self.opt.mark.blackColor; // if we have marks, this is the color
                break;
            case JGO.WHITE:
            case JGO.DIM_WHITE:
                self.ctx.globalAlpha = type == JGO.WHITE ? 1 : self.opt.stone.dimAlpha;
                self.stones.drawStone(self.ctx, JGO.WHITE, ox, oy);
                markColor = self.opt.mark.whiteColor; // if we have marks, this is the color
                break;
            default:
                self.ctx.globalAlpha=1;
                markColor = self.opt.mark.clearColor; // if we have marks, this is the color
            }

            // Common settings to all markers
            self.ctx.lineWidth = self.opt.mark.lineWidth;
            self.ctx.strokeStyle = markColor;

            self.ctx.font = self.opt.mark.font;
            self.ctx.fillStyle = markColor;
            self.ctx.textAlign = 'center';
            self.ctx.textBaseline = 'middle';

            if(mark) self.stones.drawMark(self.ctx, mark, ox, oy);
        }, i1, j1, i2, j2); // provide iteration limits

        this.ctx.restore(); // also restores globalAlpha
    };

    /**
    * Add an event listener to canvas (click) events. The callback will be
    * called with 'this' referring to JGO.Canvas object, with coordinate and
    * event as parameters. Supported event types are 'click', 'mousemove',
    * and 'mouseout'. With 'mouseout', there is no coordinate parameter for
    * callback.
    *
    * @param {String} event The event to listen to, e.g. 'click'.
    * @param {function} callback The callback.
    */
    JGO.Canvas.prototype.addListener = function(event, callback) {
        this.listeners[event].push(callback);
    };

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="JGO.Board.html">Board</a></li><li><a href="JGO.Canvas.html">Canvas</a></li><li><a href="JGO.Coordinate.html">Coordinate</a></li><li><a href="JGO.Node.html">Node</a></li><li><a href="JGO.Notifier.html">Notifier</a></li><li><a href="JGO.Record.html">Record</a></li><li><a href="JGO.Setup.html">Setup</a></li><li><a href="JGO.Stones.html">Stones</a></li></ul><h3>Namespaces</h3><ul><li><a href="JGO.html">JGO</a></li><li><a href="JGO.util.html">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta2</a> on Sun Mar 15 2015 15:38:06 GMT+0200 (FLE Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
